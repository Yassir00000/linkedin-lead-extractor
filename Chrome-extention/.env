// Importa la libreria. Il percorso con '/' iniziale è cruciale.
try {
    importScripts('/libs/xlsx.full.min.js');
    console.log("BACKGROUND: Libreria XLSX caricata correttamente.");
} catch (e) {
    console.error("BACKGROUND: ERRORE CRITICO - Impossibile importare la libreria XLSX. Controlla che il percorso '/libs/xlsx.full.min.js' sia corretto e che non ci sia 'type: module' in manifest.json per il background.", e);
}

// Resetta lo stato all'installazione/aggiornamento dell'estensione
chrome.runtime.onInstalled.addListener(() => {
    chrome.storage.local.set({ exportStatus: 'idle' });
});

/**
 * Converte una stringa in un formato più vicino all'ASCII.
 */
function toAscii(str) {
    if (!str) return '';
    let newStr = str
        .replace(/ß/g, 'ss').replace(/æ/g, 'ae').replace(/Æ/g, 'AE')
        .replace(/ø/g, 'o').replace(/Ø/g, 'O').replace(/å/g, 'a').replace(/Å/g, 'A')
        .replace(/ł/g, 'l').replace(/Ł/g, 'L');
    return newStr.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

/**
 * Funzione generica per chiamare l'API di Gemini e ottenere una risposta JSON.
 * @param {string} prompt - Il prompt da inviare.
 * @param {string} apiKey - La chiave API.
 * @returns {Promise<object>} - L'oggetto JSON parsato dalla risposta.
 */
async function callApi(prompt, apiKey) {
    const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent";

    const response = await fetch(`${API_URL}?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
                temperature: 0.1,
                maxOutputTokens: 8192
            }
        })
    });

    if (!response.ok) {
        const errorBody = await response.text();
        console.error("BACKGROUND: Errore API Gemini:", errorBody);
        throw new Error(`La richiesta API è fallita con stato ${response.status}.`);
    }

    const data = await response.json();
    const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!textContent) throw new Error('Nessun contenuto valido ricevuto da Gemini.');
    
    const cleanedText = textContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    try {
        return JSON.parse(cleanedText);
    } catch (e) {
        console.error("BACKGROUND: Impossibile parsare la risposta JSON di Gemini:", cleanedText);
        throw new Error('Formato JSON non valido dalla risposta di Gemini.');
    }
}

/**
 * Trova i domini per una lista di nomi di aziende univoci.
 * @param {string[]} companyNames - Array di nomi di aziende senza duplicati.
 * @param {string} apiKey - La chiave API.
 * @returns {Promise<Object<string, string>>} - Una mappa { nomeAzienda: dominio }.
 */
async function findCompanyDomains(companyNames, apiKey) {
    if (!companyNames || companyNames.length === 0) return {};
    const prompt = `Dato l'elenco di nomi di aziende, trova il dominio del sito web principale per ciascuna.
Elenco: ${JSON.stringify(companyNames)}
Rispondi ESCLUSIVAMENTE con un singolo oggetto JSON che mappa ogni nome di azienda al suo dominio (es. "azienda.com"). Se non trovi un dominio, usa "N/A".
Esempio: { "Azienda Esempio S.p.A.": "esempio.com", "Azienda Fantasma": "N/A" }`;

    console.log(`BACKGROUND: Richiesta domini per ${companyNames.length} aziende uniche.`);
    return callApi(prompt, apiKey);
}

/**
 * Suddivide i nomi completi e ne deduce il titolo.
 * @param {string[]} fullNames - Array di nomi completi.
 * @param {string} apiKey - La chiave API.
 * @returns {Promise<Object<string, {firstName: string, lastName: string, title: string}>>}
 */
async function splitContactNames(fullNames, apiKey) {
    if (!fullNames || fullNames.length === 0) return {};
    const prompt = `Per ogni nome completo nell'elenco, suddividilo in 'firstName' e 'lastName'. Inoltre, fornisci un campo 'title' ('Mr.' o 'Mrs.') basato sul genere del nome. Se il genere è ambiguo (es. Andrea), lascia il titolo come stringa vuota.
Elenco: ${JSON.stringify(fullNames)}
Rispondi ESCLUSIVAMENTE con un singolo oggetto JSON che mappa ogni nome completo all'oggetto { "firstName": "...", "lastName": "...", "title": "..." }.
Esempio: { "Mario Rossi": { "firstName": "Mario", "lastName": "Rossi", "title": "Mr." } }`;

    console.log(`BACKGROUND: Richiesta suddivisione nomi per ${fullNames.length} contatti.`);
    return callApi(prompt, apiKey);
}

/**
 * Funzione principale che orchestra l'elaborazione e il download.
 */
async function processAndDownload({ contacts, findDomains, splitNames, apiKey, selectedFolder }) {
    await chrome.storage.local.set({ exportStatus: 'processing' });
    
    console.log(`BACKGROUND: Inizio elaborazione per "${selectedFolder}".`);
    chrome.notifications.create('export-start', {
        type: 'basic', iconUrl: 'icon48.png', title: 'Esportazione Avviata',
        message: `L'elaborazione per "${selectedFolder}" è iniziata...`, priority: 1
    });

    try {
        if (typeof XLSX === 'undefined') {
            throw new Error("Libreria di esportazione (XLSX) non caricata.");
        }

        let domainMap = {};
        let nameMap = {};

        if ((findDomains || splitNames) && apiKey) {
            const apiPromises = [];

            // --- LOGICA CHIAVE PER I DOMINI ---
            if (findDomains) {
                // 1. Estrai SOLO i valori 'filteredCompany' (Azienda LinkedIn).
                // 2. Filtra via quelli nulli o vuoti.
                // 3. Usa un Set per ottenere solo i nomi unici, eliminando i duplicati.
                const uniqueLinkedInCompanies = [...new Set(contacts.map(c => c.filteredCompany).filter(Boolean))];
                
                if (uniqueLinkedInCompanies.length > 0) {
                    apiPromises.push(findCompanyDomains(uniqueLinkedInCompanies, apiKey).then(res => domainMap = res));
                } else {
                    console.log("BACKGROUND: Nessuna 'Azienda LinkedIn' valida trovata per la ricerca dei domini.");
                }
            }
            // --- FINE LOGICA CHIAVE ---

            if (splitNames) {
                const fullNames = contacts.map(c => c.personName).filter(Boolean);
                if (fullNames.length > 0) {
                    apiPromises.push(splitContactNames(fullNames, apiKey).then(res => nameMap = res));
                }
            }

            if (apiPromises.length > 0) {
                console.log(`BACKGROUND: Avvio di ${apiPromises.length} chiamate API in parallelo.`);
                await Promise.all(apiPromises);
                console.log("BACKGROUND: Tutte le chiamate API sono state completate.");
            }
        }

        // Arricchimento dei contatti con i dati ottenuti
        const processedContacts = contacts.map(contact => {
            const enrichedContact = { ...contact };

            // Associa il dominio SOLO se c'era un 'filteredCompany' e se è stato trovato nella mappa
            if (findDomains && contact.filteredCompany && domainMap[contact.filteredCompany]) {
                enrichedContact.companyDomain = domainMap[contact.filteredCompany];
            }

            // Associa nome, cognome e titolo
            if (splitNames && contact.personName && nameMap[contact.personName]) {
                const { firstName, lastName, title } = nameMap[contact.personName];
                enrichedContact.firstName = firstName;
                enrichedContact.lastName = lastName;
                enrichedContact.title = title;
            }
            return enrichedContact;
        });

        console.log("BACKGROUND: Creazione del file Excel.");
        const headers = ["Nome Completo", "Titolo", "Nome", "Cognome", "Nome (ASCII)", "Cognome (ASCII)", "Titolo Lavorativo", "Località", "Azienda Contatto", "Orbis", "Azienda LinkedIn", "Dominio Azienda", "Profilo LinkedIn", "URL Pagina LinkedIn", "Numero Contatti Azienda"];
        const ws_data = [headers, ...processedContacts.map(c => [
            c.personName || '', c.title || '', c.firstName || '', c.lastName || '',
            toAscii(c.firstName || ''), toAscii(c.lastName || ''),
            c.jobTitle || '', c.location || '', c.companyName || '',
            c.orbisName || '', c.filteredCompany || '', c.companyDomain || '',
            c.profileLink || '', c.pageUrl || '', c.numeroContattiPerAzienda || ''
        ])];

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(ws_data);
        XLSX.utils.book_append_sheet(wb, ws, "Contatti");

        const wbout_base64 = XLSX.write(wb, { bookType: 'xlsx', type: 'base64' });
        const dataUri = 'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + wbout_base64;
        
        chrome.downloads.download({
            url: dataUri,
            filename: `${selectedFolder}_contatti_arricchiti.xlsx`,
            saveAs: true
        });

        chrome.notifications.create('export-success', {
            type: 'basic', iconUrl: 'icon48.png', title: 'Esportazione Completata',
            message: `Il file per "${selectedFolder}" è pronto per essere salvato.`, priority: 2
        });

    } catch (error) {
        console.error("BACKGROUND: ERRORE DURANTE L'ESPORTAZIONE:", error);
        chrome.notifications.create('export-error', {
            type: 'basic', iconUrl: 'icon48.png', title: 'Errore di Esportazione',
            message: `Dettagli: ${error.message}`, priority: 2
        });
    } finally {
        await chrome.storage.local.set({ exportStatus: 'idle' });
        console.log("BACKGROUND: Processo terminato. Stato impostato su 'idle'.");
    }
}

// Listener principale per i messaggi dal popup
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'processContactsForExport') {
        processAndDownload(message.payload);
        return true; // Indica che il processo è asincrono
    }
});

---

/**
 * Funzione di avvio del content script.
 * Ora esegue direttamente l'inizializzazione dell'observer per l'UI.
 */
(function initialize() {
    console.log('Contacts Miner: Inizializzazione del content script...');
    initializeUIObserver();
})();

/**
 * Mostra una notifica temporanea (toaster) in basso a destra dello schermo.
 * @param {string} message - Il messaggio da visualizzare.
 * @param {'success'|'error'} type - Il tipo di notifica, per il colore di sfondo.
 */
function showNotification(message, type = 'error') {
    const notification = document.createElement('div');
    notification.innerText = message;
    Object.assign(notification.style, {
        position: 'fixed',
        bottom: '20px',
        right: '20px',
        backgroundColor: type === 'success' ? '#28a745' : '#d9534f',
        color: '#fff',
        padding: '10px 20px',
        borderRadius: '5px',
        boxShadow: '0 2px 10px rgba(0, 0, 0, 0.2)',
        zIndex: '9999',
        transition: 'opacity 0.5s',
        opacity: '1',
    });
    document.body.appendChild(notification);

    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => document.body.removeChild(notification), 500);
    }, 3000);
}

/**
 * Funzione per lo scorrimento automatico di un container o della finestra.
 * @param {string|null} containerSelector - Selettore CSS del container. Se null, scorre la finestra.
 * @returns {Promise<void>}
 */
function autoScroll(containerSelector = null) {
    return new Promise(resolve => {
        const element = containerSelector ? document.querySelector(containerSelector) : window;
        const scroller = containerSelector ? element : document.documentElement;

        const interval = setInterval(() => {
            const isAtBottom = containerSelector
                ? scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10
                : window.innerHeight + window.scrollY >= document.body.scrollHeight - 10;

            if (isAtBottom) {
                clearInterval(interval);
                resolve();
            } else {
                element.scrollBy(0, 250);
            }
        }, 100);
    });
}

/**
 * --- VERSIONE FUNZIONANTE RIPRISTINATA ---
 * Estrae i nomi da TUTTI i filtri "Azienda attuale" attivi.
 * @returns {string|null} - Una stringa con i nomi delle aziende separati da virgola, o null.
 */
function extractFilteredCompanyNames() {
    const companyNames = [];
    const companyFilterContainer = document.querySelector('fieldset[data-x-search-filter="CURRENT_COMPANY"]');

    if (companyFilterContainer) {
        const pillElements = companyFilterContainer.querySelectorAll('.artdeco-pill--green');
        pillElements.forEach(pill => {
            const nameElement = pill.querySelector('span.nowrap-ellipsis');
            if (nameElement) {
                companyNames.push(nameElement.innerText.trim());
            }
        });
    }
    
    return companyNames.length > 0 ? companyNames.join(', ') : null;
}


/**
 * Funzione centralizzata per estrarre i dati di un contatto da un elemento <li>.
 * @param {HTMLElement} liElement - L'elemento <li> del contatto.
 * @returns {object|null}
 */
function extractContactData(liElement) {
    try {
        const personName = liElement.querySelector("span[data-anonymize='person-name']")?.innerText.trim() || "N/A";
        const jobTitle = liElement.querySelector("span[data-anonymize='title']")?.innerText.trim() || "N/A";
        
        let companyName = "N/A";
        const companyElement = liElement.querySelector("a[data-anonymize='company-name']") || liElement.querySelector("div.artdeco-entity-lockup__subtitle");
        if (companyElement) {
            const rawText = companyElement.innerText.trim();
            companyName = jobTitle !== "N/A" && rawText.startsWith(jobTitle) ? rawText.replace(jobTitle, "").trim() : rawText;
        }

        let profileLink = liElement.querySelector("a[data-control-name='view_lead_panel_via_search_lead_name']")?.href || "N/A";
        if (profileLink.includes(',')) {
            profileLink = profileLink.split(',')[0];
        }

        const location = liElement.querySelector("span[data-anonymize='location']")?.innerText.trim() || "N/A";
        const profileImage = liElement.querySelector("img[data-anonymize='headshot-photo']")?.src || "";

        const resultsElement = document.querySelector('.t-14.flex.align-items-center.mlA.pl3 > span');
        const numeroContattiPerAzienda = resultsElement ? resultsElement.innerText.trim().replace(/\s*(risultati|results)$/i, '').trim() : "N/A";
        
        const filteredCompanies = extractFilteredCompanyNames();

        return {
            personName, jobTitle, companyName, location, profileLink, profileImage,
            pageUrl: window.location.href,
            numeroContattiPerAzienda,
            filteredCompany: filteredCompanies,
        };
    } catch (error) {
        console.error("Errore durante l'estrazione dei dati del contatto:", error);
        return null;
    }
}

/**
 * Invia i dati estratti al background per salvarli nella cartella selezionata.
 * (MODIFICATO: non controlla più lo switch, salva sempre il filtro se trovato).
 * @param {object} contactData - Dati del contatto.
 */
async function sendExtractedDataToFolder(contactData) {
    const { folders, selectedFolder, currentOrbisName } = await chrome.storage.local.get(['folders', 'selectedFolder', 'currentOrbisName']);

    if (!selectedFolder) {
        showNotification('Seleziona una cartella prima di salvare i contatti', 'error');
        return;
    }
    
    // Il controllo per 'isCompanyFilterActive' è stato RIMOSSO.
    // Il campo 'filteredCompany' verrà salvato così com'è stato estratto.

    const allFolders = folders || {};
    const contactsInFolder = allFolders[selectedFolder] || [];
    
    if (currentOrbisName) contactData.orbisName = currentOrbisName;

    const existingContactIndex = contactsInFolder.findIndex(c => c.profileLink === contactData.profileLink);

    if (existingContactIndex > -1) {
        contactsInFolder.splice(existingContactIndex, 1);
        showNotification(`Il contatto "${contactData.personName}" è stato rimosso`, 'error');
    } else {
        contactsInFolder.push(contactData);
        showNotification(`Contatto aggiunto: ${contactData.personName}`, 'success');
    }
    
    allFolders[selectedFolder] = contactsInFolder;
    await chrome.storage.local.set({ folders: allFolders });
}

/**
 * Applica i badge "Aggiunto" ai contatti già salvati nella cartella corrente.
 */
async function loadAndApplyBadges() {
    const { folders, selectedFolder } = await chrome.storage.local.get(['folders', 'selectedFolder']);
    if (!selectedFolder || !folders?.[selectedFolder]) return;

    const savedProfileLinks = new Set(folders[selectedFolder].map(contact => contact.profileLink));

    document.querySelectorAll('li.artdeco-list__item').forEach(liElement => {
        let profileLink = liElement.querySelector("a[data-control-name='view_lead_panel_via_search_lead_name']")?.href;
        if (!profileLink) return;

        if (profileLink.includes(',')) {
            profileLink = profileLink.split(',')[0];
        }

        const titleElement = liElement.querySelector(".artdeco-entity-lockup__title");
        if (!titleElement) return;

        let badge = titleElement.querySelector('.badge-saved-contact');
        
        if (savedProfileLinks.has(profileLink)) {
            if (!badge) {
                badge = document.createElement('span');
                badge.className = 'badge-saved-contact';
                badge.innerText = 'Aggiunto';
                Object.assign(badge.style, {
                    backgroundColor: '#28a745', color: '#fff', fontSize: '12px',
                    padding: '2px 6px', borderRadius: '4px', marginLeft: '5px'
                });
                titleElement.appendChild(badge);
            }
        } else {
            badge?.remove();
        }
    });
}

/**
 * Estrae tutti i contatti visibili e non ancora salvati.
 * (MODIFICATO: non controlla più lo switch, salva sempre il filtro se trovato).
 */
async function extractAllVisibleContacts() {
    const { folders, selectedFolder, currentOrbisName } = await chrome.storage.local.get(['folders', 'selectedFolder', 'currentOrbisName']);
    
    if (!selectedFolder) {
        showNotification('Seleziona una cartella prima di estrarre i contatti', 'error');
        return;
    }

    showNotification('Scansione e estrazione in corso...', 'success');
    await autoScroll('#search-results-container');

    const allFolders = folders || {};
    const contactsInFolder = allFolders[selectedFolder] || [];
    const savedProfileLinks = new Set(contactsInFolder.map(c => c.profileLink));
    const newContacts = [];

    document.querySelectorAll('li.artdeco-list__item').forEach(liElement => {
        const contactData = extractContactData(liElement);
        if (contactData && !savedProfileLinks.has(contactData.profileLink)) {
            if (currentOrbisName) contactData.orbisName = currentOrbisName;
            // La logica di controllo per 'filteredCompany' è stata rimossa.
            newContacts.push(contactData);
        }
    });

    if (newContacts.length > 0) {
        allFolders[selectedFolder] = [...contactsInFolder, ...newContacts];
        await chrome.storage.local.set({ folders: allFolders });
        showNotification(`${newContacts.length} nuovi contatti aggiunti con successo!`, 'success');
    } else {
        showNotification('Nessun nuovo contatto da aggiungere trovato sulla pagina.', 'error');
    }
}

/**
 * Inizializza l'interfaccia utente dell'estensione sulla pagina di LinkedIn.
 * (MODIFICATO: L'interruttore per il filtro azienda è stato rimosso).
 */
function initializeUI() {
    const referenceElement = document.querySelector('.flex-1._column_c69tab > fieldset:first-child');
    if (!referenceElement || document.querySelector('.sezione-nome-orbis')) return;

    // Lo stile per lo switch non è più necessario, ma lo lasciamo per non creare problemi.
    const style = document.createElement('style');
    style.textContent = `
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #28a745; }
        input:checked + .slider:before { transform: translateX(26px); }
    `;
    document.head.appendChild(style);

    const newSection = document.createElement('fieldset');
    newSection.className = 'sezione-nome-orbis pv3 _container_bguac2 _container-divider_bguac2 _column_c69tab';
    newSection.innerHTML = `
        <div class="ph4 flex align-items-center relative" style="margin-bottom: 10px; padding-left: 0;">
            <legend class="t-14 pr2 overflow-hidden t-black flex align-items-center" style="font-size: 15px; color: #0073b1;">Opzioni di Estrazione</legend>
        </div>
        <div class="ph4" style="padding-left: 0;">
            <input id="orbis-name-input" type="text" placeholder="Inserisci Nome Orbis" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; margin-bottom: 15px;">
            
            <!-- La sezione con lo switch per il filtro azienda è stata RIMOSSA -->

            <div style="display: flex; gap: 10px;">
                <button id="save-orbis-btn" style="padding: 8px 12px; background-color: #0073b1; color: #fff; border: none; border-radius: 4px; cursor: pointer; flex-grow: 1;">Salva Orbis</button>
                <button id="extract-all-btn" style="padding: 8px 12px; background-color: #28a745; color: #fff; border: none; border-radius: 4px; cursor: pointer; flex-grow: 1;">Estrai Tutti</button>
                <button id="show-badges-btn" style="padding: 8px 12px; background-color: #ffc107; color: #333; border: none; border-radius: 4px; cursor: pointer; flex-grow: 1;">Mostra Badge</button>
            </div>
            <div id="orbis-contact-count" style="margin-top: 10px; text-align: center; font-size: 13px;"></div>
        </div>`;
    
    referenceElement.insertAdjacentElement('beforebegin', newSection);
    
    const orbisInput = document.getElementById('orbis-name-input');
    const saveOrbisBtn = document.getElementById('save-orbis-btn');
    const extractAllBtn = document.getElementById('extract-all-btn');
    const showBadgesBtn = document.getElementById('show-badges-btn');
    // La variabile companyFilterSwitch e i suoi listener sono stati rimossi.

    chrome.storage.local.get(['currentOrbisName'], (result) => {
        if (result.currentOrbisName) {
            orbisInput.value = result.currentOrbisName;
            orbisInput.style.backgroundColor = '#eaffea';
        }
    });

    saveOrbisBtn.addEventListener('click', async () => {
        const orbisName = orbisInput.value.trim();
        await chrome.storage.local.set({ currentOrbisName: orbisName });
        orbisInput.style.backgroundColor = orbisName ? '#eaffea' : '#ffffff';
        showNotification('Nome Orbis salvato!', 'success');
    });

    extractAllBtn.addEventListener('click', extractAllVisibleContacts);
    showBadgesBtn.addEventListener('click', async () => {
        showNotification('Scansione e aggiornamento badge...', 'success');
        await autoScroll('#search-results-container');
        await loadAndApplyBadges();
        showNotification('Badge aggiornati!', 'success');
    });
    
    displayContactCountForOrbis();
    loadAndApplyBadges();
}

/**
 * Visualizza il numero di contatti salvati per l'Orbis corrente.
 */
async function displayContactCountForOrbis() {
    const { folders, selectedFolder, currentOrbisName } = await chrome.storage.local.get(['folders', 'selectedFolder', 'currentOrbisName']);
    const countElement = document.getElementById('orbis-contact-count');
    if (!countElement) return;

    if (!selectedFolder || !currentOrbisName || !folders?.[selectedFolder]) {
        countElement.innerHTML = '';
        return;
    }
    
    const orbisContactCount = folders[selectedFolder].filter(c => c.orbisName === currentOrbisName).length;
    countElement.innerHTML = `<strong>${orbisContactCount}</strong> contatti salvati per <strong>${currentOrbisName}</strong>`;
}

/**
 * Inizializza un MutationObserver per attendere il caricamento dell'UI di LinkedIn.
 */
function initializeUIObserver() {
    let isUiInitialized = false;
    const observer = new MutationObserver((mutations, obs) => {
        const referenceElement = document.querySelector('.flex-1._column_c69tab > fieldset:first-child');
        if (referenceElement && !isUiInitialized) {
            initializeUI();
            isUiInitialized = true;
            obs.disconnect(); // Ottimizzazione: smettiamo di osservare una volta inizializzata l'UI
        }
    });
    observer.observe(document.body, { childList: true, subtree: true });
}

// Listener per i click su tutta la pagina per salvare un singolo contatto.
document.addEventListener('click', (event) => {
    // Assicurati di non catturare click su bottoni o link dentro la card stessa
    if (event.target.closest('button, a')) {
        return;
    }

    const liElement = event.target.closest('li.artdeco-list__item');
    if (liElement?.querySelector("span[data-anonymize='person-name']")) {
        const contactData = extractContactData(liElement);
        if (contactData) {
            sendExtractedDataToFolder(contactData);
        }
    }
}, true); // Usa capturing per intercettare l'evento prima di altri listener

// Listener per aggiornare dinamicamente l'UI quando i dati cambiano.
chrome.storage.onChanged.addListener((changes, namespace) => {
    if (namespace === 'local' && (changes.folders || changes.selectedFolder || changes.currentOrbisName)) {
        if (document.querySelector('.sezione-nome-orbis')) {
            loadAndApplyBadges();
            displayContactCountForOrbis();
        }
    }
});

/* ========================================================================== */
/* ===  SalesCompanyExtractor + SYNC Google Sheets  ========================= */
/* ========================================================================== */

(function SalesCompanyExtractor() {
    const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbygJcxP-70rWQ4IJU0G5XCPH95cgvWZON5NAR_1aVlEZlO2kiC2O3DKRf3VkzjzqQ/exec';

    function sendCompanyToSheet(data) {
        fetch(APPS_SCRIPT_URL, {
            method : 'POST',
            mode   : 'no-cors',
            headers: { 'Content-Type': 'application/json' },
            body   : JSON.stringify(data)
        }).then(() => {
            console.log('[GS SYNC] Dati inviati a Google Sheets con successo');
        }).catch(err => {
            console.error('[GS SYNC] Errore invio a Google Sheets:', err);
        });
    }

    const SALES_COMPANY_REGEX = /^https:\/\/www\.linkedin\.com\/sales\/company\/\d+/;
    if (!SALES_COMPANY_REGEX.test(location.href)) return;

    console.log('[SalesCompanyExtractor] Pagina company rilevata:', location.href);

    function extractCompanyData() {
        const sidebar = document.querySelector('nav._sidebar-container_1808vy');
        if (!sidebar) return null;

        const companyName = sidebar.querySelector('[data-anonymize="company-name"]')?.innerText.trim() || 'N/A';
        const industry    = sidebar.querySelector('[data-anonymize="industry"]')?.innerText.trim()     || 'N/A';
        const location    = sidebar.querySelector('[data-anonymize="location"]')?.innerText.trim()     || 'N/A';
        let employees = 'N/A';
        const sizeEl  = sidebar.querySelector('[data-anonymize="company-size"]');
        if (sizeEl) {
            const raw = sizeEl.textContent.trim();
            if (raw) employees = raw;
        }
        let domain   = 'N/A';
        const siteA  = sidebar.querySelector('a[data-control-name="visit_company_website"]');
        if (siteA && siteA.href) {
            try   { domain = new URL(siteA.href).hostname; }
            catch { domain = siteA.href; }
        }
        return { companyName, industry, location, employees, domain };
    }

    const POLL_MS = 500, MAX_ATTEMPTS = 60;
    let attempts  = 0;
    const intervalId = setInterval(() => {
        attempts++;
        const data = extractCompanyData();

        if (data && data.employees !== 'N/A') {
            console.log('[SalesCompanyExtractor] Dati azienda estratti:', data);
            sendCompanyToSheet(data);
            clearInterval(intervalId);
        } else if (attempts >= MAX_ATTEMPTS) {
            console.warn('[SalesCompanyExtractor] Timeout, dati parziali:', data);
            if (data) sendCompanyToSheet(data);
            clearInterval(intervalId);
        }
    }, POLL_MS);
})();

---

{
    "manifest_version": 3,
    "name": "Scrapy",
    "version": "5.1",
    "description": "Estrae contatti da LinkedIn e li arricchisce con l'AI di Gemini.",
    "permissions": [
        "storage",
        "scripting",
        "downloads",
        "notifications"
    ],
    "background": {
        "service_worker": "background.js"
    },
    "content_scripts": [
        {
            "matches": ["https://www.linkedin.com/*"],
            "js": ["content.js"]
        }
    ],
    "action": {
        "default_popup": "popup.html",
        "default_icon": {
            "16": "icon16.png",
            "48": "icon48.png",
            "128": "icon128.png"
        }
    },
    "icons": {
        "16": "icon16.png",
        "48": "icon48.png",
        "128": "icon128.png"
    }
}


----

<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrapy</title>
    <style>
        :root {
            --primary-color: #0066cc;
            --primary-hover: #0052a3;
            --primary-light: #e6f3ff;
            --danger-color: #dc3545;
            --danger-hover: #c82333;
            --danger-light: #f8d7da;
            --success-color: #28a745;
            --success-hover: #218838;
            --success-light: #d4edda;
            --warning-color: #ffc107;

            --background-color: #f0f2f5; 
            --card-background: #ffffff;
            --card-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --text-muted: #adb5bd;
            
            --border-color: #e9ecef;
            --border-radius: 8px;
            
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --transition: all 0.2s ease-in-out;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-family);
            background: var(--background-color);
            width: 400px;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        #popup-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Header Section */
        .title-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-icon {
            width: 26px;
            height: 26px;
        }

        #settings-btn {
            background: none; border: none; border-radius: 50%;
            padding: 6px;
            cursor: pointer; font-size: 18px;
            color: var(--text-secondary); transition: var(--transition);
        }

        #settings-btn:hover { background: #e9e9e9; transform: rotate(90deg); }

        /* Settings Panel */
        #settings-panel {
            display: none; background: #f8f9fa;
            padding: 12px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }
        #settings-panel label { font-weight: 600; font-size: 14px; margin-bottom: 8px; display: block; }

        /* Form Controls */
        input[type="text"], input[type="password"], select {
            width: 100%; padding: 10px 12px;
            border: 1px solid var(--border-color); border-radius: var(--border-radius);
            font-size: 14px; background: #fff;
            transition: var(--transition); outline: none;
        }

        input[type="text"]:focus, input[type="password"]:focus, select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
        }

        button {
            border: none; border-radius: var(--border-radius);
            padding: 10px 14px;
            font-weight: 600; font-size: 14px; cursor: pointer;
            transition: var(--transition); display: flex;
            align-items: center; justify-content: center; gap: 8px;
        }

        /* Button Variants */
        .btn-primary { background: var(--primary-color); color: white; }
        .btn-primary:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-danger:hover { background: var(--danger-hover); transform: translateY(-1px); }
        .btn-success { background: var(--success-color); color: white; }
        .btn-success:hover { background: var(--success-hover); transform: translateY(-1px); }
        .btn-success:disabled { background: var(--text-muted); cursor: not-allowed; transform: none; }

        /* MODIFICA: Stile per entrambi i contenitori di gestione cartelle */
        .folder-management, .folder-selection { 
            display: flex; 
            gap: 8px; 
        }
        .folder-management input, .folder-selection select { 
            flex-grow: 1; 
        }
        .folder-management button, .folder-selection button { 
            flex-shrink: 0; 
        }

        /* Section Divider */
        hr { border: none; height: 1px; background-color: var(--border-color); margin: 0; }

        /* Contacts Section */
        .contacts-section { display: flex; flex-direction: column; gap: 8px; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .header h2 { font-size: 16px; font-weight: 600; }
        #contact-count {
            background: var(--primary-color); color: white;
            padding: 3px 9px;
            border-radius: 16px;
            font-size: 12px; font-weight: 600;
        }

        #contact-list {
            max-height: 220px;
            overflow-y: auto; background: var(--card-background);
            border: 1px solid var(--border-color); border-radius: var(--border-radius);
            padding: 6px;
        }
        .contact-card {
            padding: 8px;
            display: flex; align-items: center; gap: 12px;
            border-radius: 8px; margin-bottom: 4px;
        }
        .contact-card:hover { background: var(--primary-light); }
        .contact-card:last-child { margin-bottom: 0; }
        .contact-card img { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; }
        .contact-info { flex-grow: 1; min-width: 0; line-height: 1.3; }
        .contact-info .name a { font-weight: 600; font-size: 14px; color: var(--primary-color); text-decoration: none; }
        .contact-info .headline, .contact-info .company, .contact-info .location { font-size: 12px; color: var(--text-secondary); }
        .contact-info .orbis-name { display: none; }

        .delete-contact {
            background: #f1f1f1; color: var(--text-secondary); border-radius: 50%;
            width: 30px; height: 30px; font-size: 14px;
            padding: 0; min-width: 30px; flex-shrink: 0;
            font-weight: bold;
        }
        .delete-contact:hover { background: var(--danger-color); color: white; transform: scale(1.1); }

        /* Export Options */
        .export-options {
            background: #f8f9fa; padding: 12px;
            border: 1px solid var(--border-color); border-radius: var(--border-radius);
        }
        .checkbox-container { display: flex; align-items: center; margin-bottom: 8px; }
        .checkbox-container:hover { background: #f1f1f1; border-radius: 8px; }
        .checkbox-container:last-of-type { margin-bottom: 0; }
        .checkbox-container input[type="checkbox"] { width: 16px; height: 16px; margin-right: 12px; accent-color: var(--success-color); cursor: pointer; }
        .checkbox-container label { font-size: 14px; cursor: pointer; font-weight: 500; }

        /* Notification & Empty State */
        #notification { padding: 10px; border-radius: var(--border-radius); font-weight: 500; font-size: 14px; }
        .notification-success { background: var(--success-light); color: var(--success-color); }
        .notification-error { background: var(--danger-light); color: var(--danger-color); }
        .empty-state { padding: 20px; text-align: center; color: var(--text-muted); font-style: italic; }
        .processing::after { background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent); }
    </style>
</head>
<body>
    <div id="popup-content">
        <div class="title-bar">
            <h1>
                <img src="icon48.png" alt="Scrapy Icon" class="header-icon">
                Scrapy
            </h1>
            <button id="settings-btn" title="Impostazioni API">⚙️</button>
        </div>

        <div id="settings-panel">
            <label for="gemini-api-key">Chiave API Gemini</label>
            <input type="password" id="gemini-api-key" placeholder="Incolla la tua chiave API qui">
            <button id="save-api-key-btn" class="btn-primary" style="margin-top: 10px; width: 100%;">Salva Chiave</button>
        </div>
        
        <div id="notification" style="display: none;"></div>
        
        <div class="folder-management">
            <input type="text" id="folder-name" placeholder="Nome nuova cartella...">
            <button id="create-folder" class="btn-primary">Crea</button>
        </div>
        
        <!-- MODIFICA: Contenitore aggiunto per allineare tendina e pulsante -->
        <div class="folder-selection">
            <select id="folder-select">
                <option value="">Seleziona una cartella</option>
            </select>
            <!-- MODIFICA: Stile inline rimosso e testo accorciato -->
            <button id="delete-folder" class="btn-danger">Elimina</button>
        </div>
        
        <hr>
        
        <div class="contacts-section">
            <div class="header">
                <h2>Contatti Salvati</h2>
                <span id="contact-count">0</span>
            </div>
            
            <div id="contact-list">
                <div class="contact-card">
                    <img src="icon48.png" alt="Profile Picture">
                    <div class="contact-info">
                        <div class="name"><a href="#" target="_blank">Mario Rossi</a></div>
                        <div class="headline">Software Engineer</div>
                        <div class="company">Tech Solutions Inc.</div>
                        <div class="location">Milano, Italia</div>
                        <div class="orbis-name">Orbis Name: M. Rossi</div>
                    </div>
                    <button class="delete-contact" title="Elimina Contatto">X</button>
                </div>
                <div class="empty-state" style="display: none;">
                    Seleziona una cartella per vedere i contatti
                </div>
            </div>
        </div>

        <div class="export-options">
            <div class="checkbox-container">
                <input type="checkbox" id="find-domains-checkbox">
                <label for="find-domains-checkbox">Trova domini delle aziende</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="split-names-checkbox">
                <label for="split-names-checkbox">Suddividi nomi e cognomi (con titolo)</label>
            </div>
            <button id="download-excel" class="btn-success" style="display: none; width: 100%; margin-top: 10px;">Esporta in Excel</button>
        </div>
    </div>

    <script src="popup.js"></script>
</body>
</html>


---

//popup.js
document.addEventListener('DOMContentLoaded', initializePopup);

function toAscii(str) {
    if (!str) return '';
    let newStr = str
        .replace(/ß/g, 'ss').replace(/æ/g, 'ae').replace(/Æ/g, 'AE')
        .replace(/ø/g, 'o').replace(/Ø/g, 'O').replace(/å/g, 'a').replace(/Å/g, 'A')
        .replace(/ł/g, 'l').replace(/Ł/g, 'L');
    return newStr.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

function initializePopup() {
    // Selettori elementi UI
    const folderSelect = document.getElementById('folder-select');
    const createFolderButton = document.getElementById('create-folder');
    const folderNameInput = document.getElementById('folder-name');
    const deleteFolderButton = document.getElementById('delete-folder');
    const contactList = document.getElementById('contact-list');
    const contactCount = document.getElementById('contact-count');
    const downloadExcelButton = document.getElementById('download-excel');
    const notification = document.getElementById('notification');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const apiKeyInput = document.getElementById('gemini-api-key');
    const saveApiKeyBtn = document.getElementById('save-api-key-btn');
    const findDomainsCheckbox = document.getElementById('find-domains-checkbox');
    const splitNamesCheckbox = document.getElementById('split-names-checkbox');

    function showNotification(message, type = 'success', duration = 3000) {
        notification.textContent = message;
        notification.style.backgroundColor = type === 'success' ? '#d4edda' : (type === 'error' ? '#f8d7da' : '#cce5ff');
        notification.style.color = type === 'success' ? '#155724' : (type === 'error' ? '#721c24' : '#004085');
        notification.style.display = 'block';
        notification.style.opacity = '1';
        if (duration > 0) {
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => { notification.style.display = 'none'; }, 500);
            }, duration);
        }
    }

    function setExportButtonState(status) {
        if (status === 'processing') {
            downloadExcelButton.disabled = true;
            downloadExcelButton.textContent = 'Elaborazione in corso...';
            downloadExcelButton.classList.add('processing');
        } else { // 'idle' or any other state
            downloadExcelButton.disabled = false;
            downloadExcelButton.textContent = 'Esporta in Excel';
            downloadExcelButton.classList.remove('processing');
        }
    }

    async function loadFolders() {
        const { folders, selectedFolder } = await chrome.storage.local.get(['folders', 'selectedFolder']);
        const allFolders = folders || {};
        folderSelect.innerHTML = '<option value="">Seleziona una cartella</option>';
        Object.keys(allFolders).forEach(folderName => {
            const option = document.createElement('option');
            option.value = folderName;
            option.textContent = folderName;
            folderSelect.appendChild(option);
        });
        if (selectedFolder && allFolders[selectedFolder]) {
            folderSelect.value = selectedFolder;
            await loadContacts(selectedFolder);
        } else {
            await chrome.storage.local.remove('selectedFolder');
            await loadContacts(null);
        }
    }

    async function loadContacts(folderName) {
        if (!folderName) {
            contactList.innerHTML = '<p>Seleziona una cartella per vedere i contatti.</p>';
            contactCount.textContent = '0';
            downloadExcelButton.style.display = 'none';
            return;
        }
        const { folders, exportStatus } = await chrome.storage.local.get(['folders', 'exportStatus']);
        const contacts = folders?.[folderName] || [];
        contactCount.textContent = contacts.length;
        contactList.innerHTML = '';
        if (contacts.length > 0) {
            downloadExcelButton.style.display = 'block';
            setExportButtonState(exportStatus || 'idle');
            contacts.forEach((contact, index) => {
                const card = document.createElement('div');
                card.className = 'contact-card';
                card.innerHTML = `<img src="${contact.profileImage || 'icon48.png'}" alt="Foto Profilo"><div class="contact-info"><div class="name"><a href="${contact.profileLink}" target="_blank">${contact.personName||'N/A'}</a></div><div class="headline">${contact.jobTitle||'N/A'}</div><div class="company">${contact.companyName||'N/A'}</div><div class="location">${contact.location||'N/A'}</div>${contact.orbisName?`<div class="orbis-name">Orbis: ${contact.orbisName}</div>`:''}${contact.filteredCompany?`<div class="orbis-name" style="color: #0073b1;">LinkedIn: ${contact.filteredCompany}</div>`:''}</div><button class="delete-contact" data-index="${index}">×</button>`;
                contactList.appendChild(card);
            });
            contactList.querySelectorAll('.delete-contact').forEach(btn => {
                btn.addEventListener('click', (e) => removeContact(folderName, parseInt(e.currentTarget.dataset.index, 10)));
            });
        } else {
            contactList.innerHTML = '<p>Nessun contatto in questa cartella.</p>';
            downloadExcelButton.style.display = 'none';
        }
    }

    async function removeContact(folderName, index) {
        const { folders } = await chrome.storage.local.get('folders');
        if (!folders?.[folderName]) return;
        folders[folderName].splice(index, 1);
        await chrome.storage.local.set({ folders });
        await loadContacts(folderName);
    }

    settingsBtn.addEventListener('click', () => { settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block'; });

    saveApiKeyBtn.addEventListener('click', async () => {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
            await chrome.storage.local.set({ geminiApiKey: apiKey });
            showNotification('Chiave API salvata!', 'success');
            apiKeyInput.value = '';
            settingsPanel.style.display = 'none';
        } else {
            showNotification('Inserisci una chiave API valida.', 'error');
        }
    });

    createFolderButton.addEventListener('click', async () => {
        const folderName = folderNameInput.value.trim();
        if (!folderName) { showNotification('Il nome non può essere vuoto.', 'error'); return; }
        const { folders } = await chrome.storage.local.get('folders');
        const allFolders = folders || {};
        if (allFolders[folderName]) { showNotification('Cartella già esistente.', 'error'); return; }
        allFolders[folderName] = [];
        await chrome.storage.local.set({ folders: allFolders, selectedFolder: folderName });
        folderNameInput.value = '';
        showNotification('Cartella creata!', 'success');
        await loadFolders();
    });

    folderSelect.addEventListener('change', async (e) => {
        await chrome.storage.local.set({ selectedFolder: e.target.value });
        await loadContacts(e.target.value);
    });

    deleteFolderButton.addEventListener('click', async () => {
        const selectedFolder = folderSelect.value;
        if (!selectedFolder) { showNotification('Seleziona una cartella.', 'error'); return; }
        if (confirm(`Sei sicuro di eliminare la cartella "${selectedFolder}"?`)) {
            const { folders } = await chrome.storage.local.get('folders');
            delete folders[selectedFolder];
            await chrome.storage.local.set({ folders });
            await chrome.storage.local.remove('selectedFolder');
            showNotification('Cartella eliminata.', 'success');
            await loadFolders();
        }
    });

    downloadExcelButton.addEventListener('click', async () => {
        console.log("POPUP: Click su 'Esporta'.");
        const { folders, selectedFolder, geminiApiKey } = await chrome.storage.local.get(['folders', 'selectedFolder', 'geminiApiKey']);
        const contacts = folders?.[selectedFolder] || [];
        if (contacts.length === 0) { showNotification('Nessun contatto da esportare.', 'error'); return; }
        
        const doFindDomains = findDomainsCheckbox.checked;
        const doSplitNames = splitNamesCheckbox.checked;

        // --- FIX: CORRETTO L'ERRORE DI BATTITURA QUI ---
        if ((doFindDomains || doSplitNames) && !geminiApiKey) {
            showNotification('Inserisci una chiave API per usare le funzioni AI.', 'error');
            return;
        }

        setExportButtonState('processing');
        showNotification('Avvio elaborazione in background... Riceverai una notifica quando il file sarà pronto.', 'info', 5000);

        chrome.runtime.sendMessage({
            action: 'processContactsForExport',
            payload: { contacts, findDomains: doFindDomains, splitNames: doSplitNames, apiKey: geminiApiKey, selectedFolder }
        });

        setTimeout(() => window.close(), 1500);
    });

    // Controlla lo stato all'avvio e aggiorna l'UI
    chrome.storage.local.get('exportStatus', ({ exportStatus }) => {
        setExportButtonState(exportStatus || 'idle');
    });

    // Aggiorna l'UI se lo stato cambia mentre il popup è aperto
    chrome.storage.onChanged.addListener((changes, area) => {
        if (area === 'local' && changes.exportStatus) {
            setExportButtonState(changes.exportStatus.newValue);
        }
    });

    loadFolders();
    chrome.storage.local.get(['geminiApiKey'], ({ geminiApiKey }) => {
        if (geminiApiKey) apiKeyInput.placeholder = "•••••••••••••••••••••";
    });
}


